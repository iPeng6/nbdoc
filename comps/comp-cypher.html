<template component>
  <style>
    textarea {
      width: 100%;
      height: 200px;
      margin-bottom: 16px;
      padding: 8px;
      font-size: 16px;
    }

    button {
      padding: 8px 16px;
      font-size: 16px;
      margin-right: 16px;
    }

    #output {
      margin-top: 16px;
      padding: 8px;
      font-size: 16px;
      border: 1px solid #ccc;
    }
  </style>
  <div>
    <h2>密语编解码</h2>
    <textarea name="source" id="source" placeholder="粘贴需要进行转换的字符串" sync:value="source"></textarea>
    <button on:click="encode()">编码</button>
    <button on:click="decode()">解码</button>
    <pre id="output">{{output}}</pre>
  </div>
  <script>
    function encodeURL(url) {
      const mapping = {
        'a': '阿', 'b': '玻', 'c': '呲', 'd': '嘚', 'e': '鹅', 'f': '夫', 'g': '哥', 'h': '喝',
        'i': '衣', 'j': '鸡', 'k': '科', 'l': '勒', 'm': '摸', 'n': '讷', 'o': '喔', 'p': '坡',
        'q': '七', 'r': '日', 's': '思', 't': '特', 'u': '乌', 'v': '微', 'w': '屋', 'x': '西',
        'y': '衣', 'z': '资',
        '0': '零', '1': '一', '2': '二', '3': '三', '4': '四', '5': '五', '6': '六', '7': '七', '8': '八', '9': '九',
        '.': '点', '/': '斜', ':': '冒', '-': '杠', '_': '下', '=': '等', '?': '问', '&': '和',
        '!': '叹', '@': '圈', '#': '井', '$': '刀', '%': '百', '^': '帽', '*': '星', '(': '左', ')': '右',
        '+': '加', '\'': '撇', '"': '双', ';': '分', '<': '小', '>': '大', ',': '逗', ' ': '空',
        '[': '佐', ']': '佑', '{': '括', '}': '缩', '\\': '反', '|': '竖', '`': '顿', '~': '波'
        // 可以继续添加更多字符的映射
      };

      let encoded = "";
      for (const char of url.toLowerCase()) {
        encoded += mapping[char] || char; // 如果没有映射，保留原字符
      }
      return encoded;
    }

    function decodeURL(encodedURL) {
      // 反向映射
      const reverseMapping = Object.keys(mapping).reduce((acc, key) => {
        acc[mapping[key]] = key;
        return acc;
      }, {});

      let decoded = "";
      for (let i = 0; i < encodedURL.length; i++) {
        decoded += reverseMapping[encodedURL[i]] || encodedURL[i]; // 如果没有映射，保留原字符
      }
      return decoded;
    }


    function convertUrls(text) {
      const urlRegex = /https?:\/\/(([a-zA-Z0-9_-])+(\.)?)*(:\d+)?(\/((\.)?(\?)?=?&?[a-zA-Z0-9_-](\?)?)*)*/ig;

      return text.replace(urlRegex, (url) => {
        return encodeURL(url)
      });
    }
    function convertUrlsBack(text) {

      const urlRegex = /(https?:\/\/[^\s]+)|(www\.[^\s]+)/g;

      return text.replace(urlRegex, (url) => {
        return decodeURL(url)
      });
    }
    export default {
      data: {
        source: '',
        output: ''
      },
      proto: {
        encode() {
          this.output = convertUrls(this.source)
        },
        decode() {
          this.output = convertUrlsBack(this.source)
        }
      }
    }
  </script>
</template>